/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package lycus;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.TimerTask;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;

/**
 * 
 * @author Roi
 */
public class RunInnerProbesChecks extends Thread {

	/**
	 * @param args
	 *            the command line arguments
	 */
	private static ConcurrentHashMap<String, ScheduledFuture<?>> PingerFutureMap = new ConcurrentHashMap<>();
	private static Integer PingerFutureCounter = 0;
	private static ScheduledExecutorService PingerExec = Executors
			.newScheduledThreadPool(Global.getPingerThreadCount());
	private static ConcurrentHashMap<String, ScheduledFuture<?>> PorterFutureMap = new ConcurrentHashMap<>();
	private static Integer PorterFutureCounter = 0;
	private static ScheduledExecutorService PorterExec = Executors
			.newScheduledThreadPool(Global.getPorterThreadCount());
	private static ConcurrentHashMap<String, ScheduledFuture<?>> WeberFutureMap = new ConcurrentHashMap<>();
	private static Integer WeberFutureCounter = 0;
	private static ScheduledExecutorService WeberExec = Executors
			.newScheduledThreadPool(Global.getWeberThreadCount());
	private static ConcurrentHashMap<String, ScheduledFuture<?>> SnmpProbeFutureMap = new ConcurrentHashMap<>();
	private static Integer SnmpProbeFutureCounter = 0;
	private static ScheduledExecutorService SnmpProbeExec = Executors
			.newScheduledThreadPool(Global.getSnmpThreadCount());
	private static ConcurrentHashMap<String, ScheduledFuture<?>> RblProbeFutureMap = new ConcurrentHashMap<>();
	private static Integer RblProbeFutureCounter = 0;
	private static ScheduledExecutorService RblProbeExec = Executors
			.newScheduledThreadPool(Global.getRblThreadCount());

	private static ConcurrentHashMap<String, ScheduledFuture<?>> SnmpBatchFutureMap = new ConcurrentHashMap<>();
	private static Integer SnmpBatchFutureCounter = 0;
	private static Integer SnmpProbeBatchFutureCounter = 0;
	private static ScheduledExecutorService SnmpBatchExec = Executors
			.newScheduledThreadPool(Global.getSnmpBatchThreadCount());

	// Getters/Setters
	public static ConcurrentHashMap<String, ScheduledFuture<?>> getPingerFutureMap() {
		return PingerFutureMap;
	}

	public static ConcurrentHashMap<String, ScheduledFuture<?>> getPorterFutureMap() {
		return PorterFutureMap;
	}

	public static ConcurrentHashMap<String, ScheduledFuture<?>> getRblProbeFutureMap() {
		return RblProbeFutureMap;
	}

	public static ConcurrentHashMap<String, ScheduledFuture<?>> getSnmpBatchFutureMap() {
		return SnmpBatchFutureMap;
	}

	public static ConcurrentHashMap<String, ScheduledFuture<?>> getSnmpProbeFutureMap() {
		return SnmpProbeFutureMap;
	}

	public static ConcurrentHashMap<String, ScheduledFuture<?>> getWeberFutureMap() {
		return WeberFutureMap;
	}

	public static Integer getPingerFutureCounter() {
		return PingerFutureCounter;
	}

	public static Integer getPorterFutureCounter() {
		return PorterFutureCounter;
	}

	public static Integer getWeberFutureCounter() {
		return WeberFutureCounter;
	}

	public static Integer getSnmpProbeFutureCounter() {
		return SnmpProbeFutureCounter;
	}

	public static Integer getSnmpProbeBatchFutureCounter() {
		return SnmpProbeBatchFutureCounter;
	}

	public static Integer getRblProbeFutureCounter() {
		return RblProbeFutureCounter;
	}

	public static Integer getSnmpBatchFutureCounter() {
		return SnmpBatchFutureCounter;
	}

	

	// Run Threads
	public static void RunPingerThreads(final RunnableProbe probe) {
		String rpStr = probe.getRPString();
		if (rpStr.contains(
				"788b1b9e-d753-4dfa-ac46-61c4374eeb84@inner_33695a83-654d-4177-b90d-0a89c5f0120d"))
			System.out.println("TEST");
		
		ScheduledFuture<?> future;
		future = PingerExec.scheduleAtFixedRate(probe, 0, probe.getProbe()
				.getInterval(), TimeUnit.SECONDS);
		getPingerFutureMap().put(probe.getRPString(), future);
		PingerFutureCounter++;
	}	

	public static void RunPorterThreads(final RunnableProbe probe) {
		ScheduledFuture<?> future;
		future = PorterExec.scheduleAtFixedRate(probe, 0, probe.getProbe()
				.getInterval(), TimeUnit.SECONDS);
		getPorterFutureMap().put(probe.getRPString(), future);
		PorterFutureCounter++;
	}

	public static void RunWeberThreads(final RunnableProbe probe) {
		ScheduledFuture<?> future;
		future = WeberExec.scheduleAtFixedRate(probe, 0, probe.getProbe()
				.getInterval(), TimeUnit.SECONDS);
		getWeberFutureMap().put(probe.getRPString(), future);
		WeberFutureCounter++;
	}

	public static void RunSnmpProbeThreads(final RunnableProbe probe) {
		ScheduledFuture<?> future;
		future = SnmpProbeExec.scheduleAtFixedRate(probe, 1, probe.getProbe()
				.getInterval(), TimeUnit.SECONDS);
		getSnmpProbeFutureMap().put(probe.getRPString(), future);
		SnmpProbeFutureCounter++;

	}

	public static void RunRblProbeThreads(RunnableProbe probe) {
		ScheduledFuture<?> future;
		future = RblProbeExec.scheduleAtFixedRate(probe, 1, probe.getProbe()
				.getInterval(), TimeUnit.SECONDS);
		getRblProbeFutureMap().put(probe.getRPString(), future);

		RblProbeFutureCounter++;
	}

	public static void RunSnmpBatchThreads(final SnmpProbesBatch batch) {
		ScheduledFuture<?> future;
		future = SnmpBatchExec.scheduleAtFixedRate(batch, 1,
				batch.getInterval(), TimeUnit.SECONDS);
		getSnmpBatchFutureMap().put(batch.getBatchId(), future);
		SnmpProbeBatchFutureCounter+=batch.getSnmpProbes().size();
		SnmpBatchFutureCounter++;
	}

	public static boolean addRegularRP(RunnableProbe rp) {
		if(rp==null)
			return false;
		if (rp.getProbe() instanceof PingerProbe) {
			RunInnerProbesChecks.RunPingerThreads(rp);
			PingerFutureCounter++;
			return true;
		} else if (rp.getProbe() instanceof PorterProbe) {
			RunInnerProbesChecks.RunPorterThreads(rp);
			PorterFutureCounter++;
			return true;
		} else if (rp.getProbe() instanceof WeberProbe) {
			RunInnerProbesChecks.RunWeberThreads(rp);
			WeberFutureCounter++;
			return true;
		} else if (rp.getProbe() instanceof RBLProbe) {
			RunInnerProbesChecks.RunRblProbeThreads(rp);
			RblProbeFutureCounter++;
			return true;
		} else if (rp.getProbe() instanceof SnmpProbe) {
			RunInnerProbesChecks.RunSnmpProbeThreads(rp);
			SnmpProbeFutureCounter++;
			return true;
		}
		return false;
	}
	public static boolean deleteRegularRP(RunnableProbe rp) {
		if(rp==null)
			return false;
		if (rp.getProbe() instanceof PingerProbe) {
			RunInnerProbesChecks.getPingerFutureMap().get(rp.getRPString())
					.cancel(false);
			PingerFutureCounter--;
			return true;
		} else if (rp.getProbe() instanceof PorterProbe) {
			RunInnerProbesChecks.getPorterFutureMap().get(rp.getRPString())
					.cancel(false);
			PorterFutureCounter--;
			return true;
		} else if (rp.getProbe() instanceof WeberProbe) {
			RunInnerProbesChecks.getWeberFutureMap().get(rp.getRPString())
					.cancel(false);
			WeberFutureCounter--;
			return true;
		} else if (rp.getProbe() instanceof RBLProbe) {
			RunInnerProbesChecks.getRblProbeFutureMap().get(rp.getRPString())
					.cancel(false);
			RblProbeFutureCounter--;
			return true;
		} else if (rp.getProbe() instanceof SnmpProbe) {
			RunInnerProbesChecks.getSnmpProbeFutureMap().get(rp.getRPString())
					.cancel(false);
			SnmpProbeFutureCounter--;
			return true;
		}
		return false;
	}

	


	public static void decreaseRpInBatches() {
		SnmpProbeBatchFutureCounter--;
		}
}