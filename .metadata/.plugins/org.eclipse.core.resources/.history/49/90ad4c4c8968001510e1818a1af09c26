package lycus;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ScheduledFuture;
import java.util.UUID;
import org.snmp4j.CommunityTarget;
import org.snmp4j.PDU;
import org.snmp4j.Snmp;
import org.snmp4j.TransportMapping;
import org.snmp4j.event.ResponseEvent;
import org.snmp4j.mp.SnmpConstants;
import org.snmp4j.smi.Address;
import org.snmp4j.smi.GenericAddress;
import org.snmp4j.smi.OID;
import org.snmp4j.smi.OctetString;
import org.snmp4j.smi.VariableBinding;
import org.snmp4j.transport.DefaultUdpTransportMapping;

public class SnmpManager {
	private User user;
	private HashMap<Host, HashMap<String, RunnableProbe>> probesByHosts;
	private HashMap<String, SnmpProbesBatch> batches;// batchId:hostId@templateId@interval@batchUUID
	private Set<Host> inactiveHostSnmpProblem;

	public SnmpManager(User u) {
		this.setUser(u);
		this.setProbesByHosts(new HashMap<Host, HashMap<String, RunnableProbe>>());
		this.setBatches(new HashMap<String, SnmpProbesBatch>());
		this.setInactiveHostSnmpProblem(new HashSet<Host>());
	}

	// Getters/Setters
	public HashMap<String, SnmpProbesBatch> getBatches() {
		return batches;
	}

	public void setBatches(HashMap<String, SnmpProbesBatch> batches) {
		this.batches = batches;
	}

	public User getUser() {
		return user;
	}

	public void setUser(User user) {
		this.user = user;
	}

	public HashMap<Host, HashMap<String, RunnableProbe>> getProbesByHosts() {
		return probesByHosts;
	}

	public void setProbesByHosts(HashMap<Host, HashMap<String, RunnableProbe>> probesByHosts) {
		this.probesByHosts = probesByHosts;
	}

	public Set<Host> getInactiveHostSnmpProblem() {
		return inactiveHostSnmpProblem;
	}

	public void setInactiveHostSnmpProblem(Set<Host> inactiveHostSnmpProblem) {
		this.inactiveHostSnmpProblem = inactiveHostSnmpProblem;
	}

	public HashMap<String,RunnableProbe> getAllRPS()
	{
		HashMap<String,RunnableProbe> rps=new HashMap<String,RunnableProbe>();
		HashMap<Host, HashMap<String, RunnableProbe>> _probesByHosts=this.getProbesByHosts();
		for(Map.Entry<Host, HashMap<String,RunnableProbe>> entry:_probesByHosts.entrySet())
		{
			rps.putAll(entry.getValue());
		}
		return rps;
	}
	public void addRPlistToManager(List<RunnableProbe> rps) {
		for (RunnableProbe rp : rps) {
			Host _h = rp.getHost();
			if (this.getProbesByHosts().containsKey(_h)) {
				this.getProbesByHosts().get(_h).put(rp.getRPString(), rp);
			} else {
				this.getProbesByHosts().put(_h, new HashMap<String, RunnableProbe>());
				this.getProbesByHosts().get(_h).put(rp.getRPString(), rp);
			}
			this.addRPtoBatches(rp);
		}
	}

	public void runAllBatches() {
			for (SnmpProbesBatch _batch : this.getBatches().values()) {
				RunInnerProbesChecks.RunSnmpBatchThreads(_batch);
			}
	}

	/** Return SnmpProbesBatch if new created, Return null if only added to SnmpProbesBatch*/
	private SnmpProbesBatch addRPtoBatches(RunnableProbe rp) {
			Map<String, SnmpProbesBatch> _batches = this.getBatches();
			for (Map.Entry<String, SnmpProbesBatch> _batch : _batches.entrySet()) {
				String batchHostId=_batch.getKey().split("@")[0];
				String batchTemplateId = _batch.getKey().split("@")[1];
				long batchInterval = Long.parseLong(_batch.getKey().split("@")[2]);
				if (batchHostId.equals(rp.getProbe().getTemplate_id().toString())&&batchTemplateId.equals(rp.getProbe().getTemplate_id().toString())
						&& batchInterval == rp.getProbe().getInterval()
						&& _batch.getValue().getSnmpProbes().size() < this.getBatchesSize()) {
					_batch.getValue().getSnmpProbes().put(rp.getRPString(), rp);
					return null;
				}
		}
			SnmpProbesBatch newBatch = new SnmpProbesBatch(this, rp);
			_batches.put(newBatch.getBatchId(), newBatch);
			return newBatch;
		
	}

	public int getBatchesSize() {
		return 1400 / Global.getMaxSnmpResponseInBytes();
	}

	public boolean stopProbe(RunnableProbe rp) {
		ConcurrentHashMap<String,ScheduledFuture<?>> snmpBatchThreads=RunInnerProbesChecks.getSnmpBatchFutureMap();
		for(Map.Entry<String, ScheduledFuture<?>> batchThread:snmpBatchThreads.entrySet())
		{
			if(batchThread.getKey().contains(rp.getProbe().getTemplate_id().toString()))
			{
				SnmpProbesBatch batch=this.getBatches().get(batchThread.getKey());
				if(batch.getSnmpProbes().get(rp.getRPString())!=null)
				{
					batch.deleteSnmpProbe(rp);
					if(batch.getSnmpProbes().size()==0)
					{
						this.getBatches().remove(batch.getBatchId());
						RunInnerProbesChecks.getSnmpBatchFutureMap().get(batch.getBatchId()).cancel(true);
					}
					this.getProbesByHosts().get(rp.getHost()).remove(rp.getRPString());
					if(this.getProbesByHosts().get(rp.getHost()).size()==0)
						this.getProbesByHosts().remove(rp.getHost().getHostId());
					return true;
				}
			}
		}
		return false;
	}
	// 2-new batch added, 1-added to existing batch, 0-didn't added
	public int startProbe(RunnableProbe rp) {
		if(rp!=null)
		{
		Host _h = rp.getHost();
		if (this.getProbesByHosts().containsKey(_h)) {
			this.getProbesByHosts().get(_h).put(rp.getRPString(), rp);
		} else {
			this.getProbesByHosts().put(_h, new HashMap<String, RunnableProbe>());
			this.getProbesByHosts().get(_h).put(rp.getRPString(), rp);
		}
		SnmpProbesBatch batch=this.addRPtoBatches(rp);
		if(batch==null)
			return 1;
		RunInnerProbesChecks.RunSnmpBatchThreads(batch);
		return 2;
		}
		return 0;
	}
}
